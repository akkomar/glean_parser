package glean

// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at http://mozilla.org/MPL/2.0/.

// AUTOGENERATED BY {current_version}. DO NOT EDIT.

// required imports
import (
	"encoding/json"
	"time"

	"github.com/google/uuid"
)

// log type string used to identify logs to process in the Moz Data Pipeline
var gleanEventMozlogType string = "glean-server-event"

// interface to send the log messages, accepting a call passing in the eventType and the message.
// TODO: confirm what calls to cloud logging would be required to see if the log method signature makes sense
// TODO: confirm if this should depend on https://github.com/mozilla-services/go-mozlog
type Logger interface {
	log(eventType string, message string)
}

type GleanEventsLogger struct {
	AppID             string
	AppDisplayVersion string
	AppChannel        string
	Logger            Logger
}

// exported type for public method parameters
type RequestInfo struct {
	UserAgent string
	IpAddress string
}

// TODO: verify with data team what defaults make sense for user agent / ip address if they are not supplied
var defaultRequestInfo = RequestInfo{
	UserAgent: "Unknown",
	IpAddress: "Unknown",
}

// structs to construct the glean ping
type clientInfo struct {
	TelemetrySDKBuild string `json:"telemetry_sdk_build"`
	FirstRunDate      string `json:"first_run_date"`
	OS                string `json:"os"`
	OSVersion         string `json:"os_version"`
	Architecture      string `json:"architecture"`
	AppBuild          string `json:"app_build"`
	AppDisplayVersion string `json:"app_display_version"`
	AppChannel        string `json:"app_channel"`
}

type pingInfo struct {
	Seq       int    `json:"seq"`
	StartTime string `json:"start_time"`
	EndTime   string `json:"end_time"`
}

type ping struct {
	DocumentNamespace string `json:"document_namespace"`
	DocumentType      string `json:"document_type"`
	DocumentVersion   string `json:"document_version"`
	DocumentID        string `json:"document_id"`
	UserAgent         string `json:"user_agent"`
	IpAddress         string `json:"ip_address"`
	Payload           string `json:"payload"`
}

type metrics map[string]map[string]interface{}

type pingPayload struct {
	ClientInfo clientInfo   `json:"client_info"`
	PingInfo   pingInfo     `json:"ping_info"`
	Metrics    metrics      `json:"metrics"`
	Events     []gleanEvent `json:"events"`
}

type gleanEvent struct {
	Category  string     `json:"category"`
	Name      string     `json:"name"`
	Timestamp int64      `json:"timestamp"`
	Extra     [][]string `json:"extra"`
}

func (g GleanEventsLogger) createClientInfo() clientInfo {
	// Fields with default values are required in the Glean schema, but not used in server context
	return clientInfo{
		TelemetrySDKBuild: "{glean_parser_version}",
		FirstRunDate:      "Unknown",
		OS:                "Unknown",
		OSVersion:         "Unknown",
		Architecture:      "Unknown",
		AppBuild:          "Unknown",
		AppDisplayVersion: g.AppDisplayVersion,
		AppChannel:        g.AppChannel,
	}
}

func createPingInfo() pingInfo {
	// TODO: confirm expected date format in logs,
	// js uses Date().toISOString(), ex. "2023-12-13T20:21:55.390Z"
	// ruby uses Time.now.utc, ex. "2023-12-13 20:21:02 UTC"
	var now = time.Now().UTC().Format("2006-01-02 15:04:05 MST")
	return pingInfo{
		Seq:       0,
		StartTime: now,
		EndTime:   now,
	}
}

func (g GleanEventsLogger) createPing(documentType string, config RequestInfo, payload string) ping {
	var documentId = uuid.New()
	return ping{
		DocumentNamespace: g.AppID,
		DocumentType:      documentType,
		DocumentVersion:   "1",
		DocumentID:        documentId.String(),
		UserAgent:         config.UserAgent,
		IpAddress:         config.IpAddress,
		Payload:           string(payload),
	}
}

// method called by each event or custom ping method
func (g GleanEventsLogger) record(
	documentType string,
	requestInfo RequestInfo,
	metrics metrics,
	events []gleanEvent,
) {
	var telemetryPayload = pingPayload{
		ClientInfo: g.createClientInfo(),
		PingInfo:   createPingInfo(),
		Metrics:    metrics,
		Events:     events,
	}

	var payloadJson, payloadErr = json.Marshal(telemetryPayload)
	if payloadErr != nil {
		panic("Unable to marshal payload to json")
	}

	// TODO: confirm expected shape with data team
	// ruby implementation wraps ping in another js object before JSON.dumping to a string
	// ex. { "Timestamp": string, "Logger": name, "Type": gleanEventMozLogType, "Severity": string, "Pid": string, "Fields": pingJson }
	// js appears not to
	var ping = g.createPing(documentType, requestInfo, string(payloadJson))
	var pingJson, err = json.Marshal(ping)
	if err != nil {
		panic("Unable to marshal ping to json")
	}
	g.Logger.log(gleanEventMozlogType, string(pingJson))
}

type PingServerAction struct {
  MetricName string // Test string metric
  MetricRequestCount int64 // Test quantity metric
}

// Record and submit a PingServerAction custon Ping
func (g GleanEventsLogger) RecordPingServerAction(
	requestInfo RequestInfo,
	params PingServerAction,
) {
	var metrics = metrics{
    "string": {
      "metric.name": params.MetricName,
    },
    "quantity": {
      "metric.request_count": params.MetricRequestCount,
    },
	}
	var events = []gleanEvent{}
	g.record("server-action", requestInfo, metrics, events)
}

// Record and submit a PingServerAction custon Ping omitting user request info
func (g GleanEventsLogger) RecordPingServerActionWithoutUserInfo(
	params PingServerAction,
) {
	g.RecordPingServerAction(defaultRequestInfo, params)
}

type EventBackendTestEvent struct {
  MetricName string // Test string metric
  MetricRequestCount int64 // Test quantity metric
  EventField1 string // A first extra field
  EventField2 string // A second extra field
}

// Record and submit an EventBackendTestEvent event.
// test event
func (g GleanEventsLogger) RecordEventBackendTestEvent(
	requestInfo RequestInfo,
	params EventBackendTestEvent,
) {
	var metrics = metrics{
    "string": {
      "metric.name": params.MetricName,
    },
    "quantity": {
      "metric.request_count": params.MetricRequestCount,
    },
	}
	var extraKeys = [][]string{
    {"event_field_1", params.EventField1},
    {"event_field_2", params.EventField2},
	}
	var events = []gleanEvent{
		gleanEvent{
			Category:  "backend",
			Name:      "test_event",
			Timestamp: time.Now().UnixMilli(),
			Extra:     extraKeys,
		},
	}
	g.record("events", requestInfo, metrics, events)
}

// Record and submit an EventBackendTestEvent event omitting user request info
// test event
func (g GleanEventsLogger) RecordEventBackendTestEventWithoutUserInfo(
  params EventBackendTestEvent,
) {
	g.RecordEventBackendTestEvent(defaultRequestInfo, params)
}

